local data = require('main.data')

--W edytorze (Inspector) dla tego Game Objecta pojawi się 
--pole o nazwie speed, end_position, is_point z wartościami domyślnymi.
--widze je w skrypcie w inspektorze
go.property('speed', 0)
go.property('end_position', vmath.vector3())
go.property('is_point', false)

local function move(self)
	local duration = data.duration(self.speed, go.get_position(), self.end_position)
	local spin_direction = (math.random(1,2) ==1) and 360 or -360

	go.animate('.','euler.z',go.PLAYBACK_LOOP_FORWARD, spin_direction, go.EASING_LINEAR, duration)
	--tutek:
	--go.animate('.','euler.z',go.PLAYBACK_LOOP_FORWARD, go.get('.','euler.z'), go.EASING_LINEAR, duration / 0.5)

	 go.animate('.','position',go.PLAYBACK_ONCE_FORWARD,self.end_position,go.EASING_LINEAR,duration,0,function()
		--po dotarciu do celu usuwamy kwadrat
		msg.post('squares', 'square_removed', { id = go.get_id()})
	end)
end

function init(self)
 if self.is_point then
	 sprite.set_constant('#sprite', 'tint', data.color_one)
	else
	 sprite.set_constant('#sprite', 'tint', data.color_two)
 end

 move(self)
end

function on_message(self, message_id, message, sender)
		if message_id == hash('trigger_response') and message.enter then
			if message.other_group == hash('circle') and not self.collided then
				self.collided = true
				msg.post('#collisionobject', 'disable') --disable collisionobject to avoid multiple collisions
			end
			
			if self.is_point then
				go.animate('.', 'scale', go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 0.1, 0, function()
				--msg.post('score', 'increase_score')
				msg.post('squares', 'square_removed', { id = go.get_id()})
				end)	
				msg.post('score', 'increase_score')
				msg.post('squares', 'increase_speed')
				msg.post('circle', 'increase_speed')
			else
				--kwadrat nie jest punktowy - koniec gry
				msg.post('circle', 'end_game')
				msg.post('squares','stop')			

			end
		end
end
