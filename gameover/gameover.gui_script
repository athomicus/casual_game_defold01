local data = require('main.data')

function init(self)
	print("gameover gui_script init")
	self.replay_button = gui.get_node('replay')
	self.container = gui.get_node('container')
	self.score_label = gui.get_node('score')
	
	gui.set_color(self.score_label, data.color_one)
	gui.set_color((gui.get_node('text')), data.color_one)	
	gui.set_color(self.replay_button, data.color_two)
	gui.animate(self.container, 'position.y', 0, gui.EASING_INQUINT, 0.4, 0, function()
			msg.post(".", "acquire_input_focus")
	end)

end


function on_message(self, message_id, message, sender)
	if message_id == hash("final_score") then
		local score = message.score or 0
		gui.set_text(self.score_label, "Score: "..tostring(score))

		if message.score >= data.sd.best_score then
			data.sd.best_score = message.score
			gui.set_text(self.score_label, "New High Score: "..tostring(score))
			msg.post('main:/sound#new_best', 'play_sound')
		else
			gui.set_text(self.score_label, "Score: "..tostring(score))
		end
	end
end

function on_input(self, action_id, action)
	-- Only handle touch actions
	if action_id ~= hash("touch") then
		return
	end

	-- Pressed: scale down and remember state if press started on the button
	if action.pressed then
		if gui.pick_node(self.replay_button, action.x, action.y) then
			self.pressed_button = true
			gui.set_scale(self.replay_button, vmath.vector3(0.9))
		end

	-- Released: if we previously pressed the button, restore scale and trigger action
	elseif action.released and self.pressed_button then
		gui.set_scale(self.replay_button, vmath.vector3(1))

		if gui.pick_node(self.replay_button, action.x, action.y) then
			-- user released on the same button -> activate
			self.pressed_button = false
			msg.post('.', 'release_input_focus')
			msg.post('main:/sound#button', 'play_sound')
			gui.animate(self.container, 'position.y', data.max_y, gui.EASING_INQUINT, 0.4, 0, function()
				msg.post('main:/go', 'show_game')
			end)
		else
			-- released outside the button -> just clear the flag
			self.pressed_button = false
		end
	end
end